"""
Bayesian Risk Engine for AlphaAxiom Learning Loop v2.0

This module implements sophisticated risk modeling using Bayesian inference with 
dynamic adaptation for the AlphaAxiom trading system. It translates concepts 
from DeepMind's Alpha series frameworks into financial market contexts.
"""

import json
import numpy as np
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class RiskAssessment:
    """Represents a risk assessment generated by the Bayesian Risk Engine"""
    assessment_id: str
    symbol: str
    risk_level: float  # 0.0 to 1.0
    confidence: float  # Confidence in the risk assessment
    timestamp: datetime
    market_conditions: Dict[str, Any]
    risk_factors: Dict[str, float]
    bayesian_updates: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None

@dataclass
class RiskDecision:
    """Represents a risk-based decision made by the engine"""
    decision_id: str
    symbol: str
    action: str  # 'ACCEPT', 'REJECT', 'MODIFY', 'DEFER'
    risk_adjusted_position: float
    confidence: float
    reasoning: str
    timestamp: datetime
    expected_volatility: float = 0.0

class BayesianRiskEngine:
    """
    Sophisticated risk modeling using Bayesian inference with dynamic adaptation.
    
    This engine applies Bayesian principles from DeepMind's Alpha series frameworks
    to financial markets, using probabilistic reasoning to assess and manage risk.
    It continuously updates its beliefs about market conditions based on new data,
    similar to how AlphaZero learns through self-play.
    """
    
    def __init__(self, d1_db, kv_store):
        """
        Initialize the Bayesian Risk Engine.
        
        Args:
            d1_db: D1 database connection for persistent storage
            kv_store: KV store for fast access to risk data
        """
        self.d1 = d1_db
        self.kv = kv_store
        self.risk_models = {}
        self.prior_beliefs = {}
        self.posterior_updates = {}
        self.risk_history = []
        
        # Default risk parameters
        self.risk_params = {
            'max_position_size': 0.05,  # 5% of portfolio
            'volatility_multiplier': 2.5,
            'confidence_threshold': 0.7,
            'risk_tolerance': 0.02,  # 2% risk per trade
        }
    
    async def assess_symbol_risk(self, symbol: str, market_data: Dict) -> \
            RiskAssessment:
        """
        Assess risk for a specific symbol using Bayesian inference.
        
        Args:
            symbol: Trading symbol to assess
            market_data: Current market data and conditions
            
        Returns:
            RiskAssessment object with risk evaluation
        """
        # 1. Retrieve prior beliefs about this symbol
        prior = await self._get_prior_beliefs(symbol)
        
        # 2. Extract current market conditions
        conditions = await self._analyze_market_conditions(market_data)
        
        # 3. Identify risk factors
        risk_factors = self._identify_risk_factors(market_data, conditions)
        
        # 4. Apply Bayesian update
        posterior = self._bayesian_update(prior, market_data, risk_factors)
        
        # 5. Calculate risk level
        risk_level = self._calculate_risk_level(posterior, risk_factors)
        
        # 6. Determine confidence
        confidence = self._calculate_assessment_confidence(
            prior, posterior, market_data)
        
        # 7. Create assessment
        assessment = RiskAssessment(
            assessment_id=f"risk_{symbol}_{int(datetime.now().timestamp())}",
            symbol=symbol,
            risk_level=risk_level,
            confidence=confidence,
            timestamp=datetime.now(),
            market_conditions=conditions,
            risk_factors=risk_factors,
            bayesian_updates=posterior
        )
        
        # 8. Store assessment
        await self._store_risk_assessment(assessment)
        
        return assessment
    
    async def make_risk_based_decision(
            self, symbol: str, proposed_trade: Dict, risk_assessment: RiskAssessment
    ) -> RiskDecision:
        """
        Make a risk-based decision on a proposed trade.
        
        Args:
            symbol: Trading symbol
            proposed_trade: Details of the proposed trade
            risk_assessment: Risk assessment for the symbol
            
        Returns:
            RiskDecision object with the decision
        """
        # 1. Calculate position size based on risk
        position_size = self._calculate_risk_adjusted_position(
            proposed_trade, risk_assessment)
        
        # 2. Determine action
        action = self._determine_risk_action(
            proposed_trade, risk_assessment, position_size)
        
        # 3. Generate reasoning
        reasoning = self._generate_risk_reasoning(
            proposed_trade, risk_assessment, action, position_size)
        
        # 4. Estimate volatility
        expected_volatility = self._estimate_volatility(risk_assessment)
        
        # 5. Create decision
        decision = RiskDecision(
            decision_id=f"decision_{symbol}_{int(datetime.now().timestamp())}",
            symbol=symbol,
            action=action,
            risk_adjusted_position=position_size,
            confidence=risk_assessment.confidence,
            reasoning=reasoning,
            timestamp=datetime.now(),
            expected_volatility=expected_volatility
        )
        
        # 6. Store decision
        await self._store_risk_decision(decision)
        
        # 7. Update risk models
        await self._update_risk_models(symbol, risk_assessment, decision)
        
        return decision
    
    async def _get_prior_beliefs(self, symbol: str) -> Dict:
        """
        Retrieve prior beliefs about a symbol's risk characteristics.
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Dictionary with prior beliefs
        """
        # Check KV store first for recent data
        cached = await self.kv.get(f"risk_prior_{symbol}")
        if cached:
            return json.loads(cached)
        
        # If not in cache, check database
        result = await self.d1.execute(
            "SELECT * FROM risk_priors WHERE symbol = ? ORDER BY timestamp DESC LIMIT 1",
            symbol
        )
        
        if result:
            prior = dict(result[0])
            # Cache for future use
            await self.kv.put(f"risk_prior_{symbol}", json.dumps(prior))
            return prior
        
        # Default priors if no history
        default_prior = {
            'volatility_expectation': 0.02,
            'correlation_risk': 0.1,
            'liquidity_risk': 0.05,
            'tail_risk': 0.01,
            'observation_count': 0
        }
        
        return default_prior
    
    async def _analyze_market_conditions(self, market_data: Dict) -> Dict:
        """
        Analyze current market conditions for risk assessment.
        
        Args:
            market_data: Current market data
            
        Returns:
            Dictionary with market condition analysis
        """
        analysis = {
            'volatility_regime': 'MODERATE',
            'trend_strength': 0.0,
            'volume_profile': 'NORMAL',
            'spread_condition': 'TIGHT',
            'market_stress': 0.0
        }
        
        if 'indicators' in market_data:
            indicators = market_data['indicators']
            
            # Analyze volatility
            if 'atr' in indicators:
                atr_value = indicators['atr']
                if atr_value > 0.03:
                    analysis['volatility_regime'] = 'HIGH'
                elif atr_value > 0.015:
                    analysis['volatility_regime'] = 'MODERATE'
                else:
                    analysis['volatility_regime'] = 'LOW'
            
            # Analyze trend strength
            if 'adx' in indicators:
                adx_value = indicators['adx']
                if isinstance(adx_value, (int, float)):
                    analysis['trend_strength'] = min(1.0, adx_value / 50.0)
            
            # Analyze volume
            if 'volume_ratio' in indicators:
                vol_ratio = indicators['volume_ratio']
                if isinstance(vol_ratio, (int, float)):
                    if vol_ratio > 1.5:
                        analysis['volume_profile'] = 'HIGH'
                    elif vol_ratio < 0.5:
                        analysis['volume_profile'] = 'LOW'
        
        # Calculate market stress
        stress_factors = []
        if analysis['volatility_regime'] == 'HIGH':
            stress_factors.append(0.4)
        if analysis['volume_profile'] == 'LOW':
            stress_factors.append(0.3)
        if analysis['trend_strength'] < 0.3:
            stress_factors.append(0.2)
            
        analysis['market_stress'] = min(1.0, sum(stress_factors))
        
        return analysis
    
    def _identify_risk_factors(
            self, market_data: Dict, market_conditions: Dict
    ) -> Dict:
        """
        Identify key risk factors from market data and conditions.
        
        Args:
            market_data: Current market data
            market_conditions: Analyzed market conditions
            
        Returns:
            Dictionary with risk factors and their weights
        """
        risk_factors = {
            'volatility_risk': 0.0,
            'liquidity_risk': 0.0,
            'correlation_risk': 0.0,
            'tail_risk': 0.0,
            'regime_risk': 0.0
        }
        
        # Volatility risk
        if market_conditions['volatility_regime'] == 'HIGH':
            risk_factors['volatility_risk'] = 0.8
        elif market_conditions['volatility_regime'] == 'MODERATE':
            risk_factors['volatility_risk'] = 0.5
        else:
            risk_factors['volatility_risk'] = 0.2
        
        # Liquidity risk
        if market_conditions['volume_profile'] == 'LOW':
            risk_factors['liquidity_risk'] = 0.7
        elif market_conditions['volume_profile'] == 'NORMAL':
            risk_factors['liquidity_risk'] = 0.4
        else:
            risk_factors['liquidity_risk'] = 0.2
        
        # Correlation risk (simplified)
        risk_factors['correlation_risk'] = 0.3
        
        # Tail risk (simplified)
        if market_conditions['market_stress'] > 0.5:
            risk_factors['tail_risk'] = 0.6
        else:
            risk_factors['tail_risk'] = 0.2
        
        # Regime risk
        risk_factors['regime_risk'] = market_conditions['market_stress']
        
        return risk_factors
    
    def _bayesian_update(
            self, prior: Dict, market_data: Dict, risk_factors: Dict
    ) -> Dict:
        """
        Apply Bayesian update to risk beliefs.
        
        Args:
            prior: Prior beliefs about risk
            market_data: Current market data
            risk_factors: Identified risk factors
            
        Returns:
            Dictionary with posterior beliefs
        """
        # Simplified Bayesian update - in a full implementation, this would
        # use proper Bayesian inference with likelihood functions
        posterior = prior.copy()
        
        # Update based on new observations
        observation_weight = 0.1  # How much new data influences beliefs
        
        # Update volatility expectation
        if 'indicators' in market_data and 'atr' in market_data['indicators']:
            current_vol = market_data['indicators']['atr']
            if isinstance(current_vol, (int, float)):
                posterior['volatility_expectation'] = (
                    (1 - observation_weight) * posterior['volatility_expectation'] +
                    observation_weight * current_vol
                )
        
        # Update observation count
        posterior['observation_count'] = posterior.get('observation_count', 0) + 1
        
        return posterior
    
    def _calculate_risk_level(
            self, posterior: Dict, risk_factors: Dict
    ) -> float:
        """
        Calculate overall risk level from posterior beliefs and risk factors.
        
        Args:
            posterior: Posterior beliefs
            risk_factors: Identified risk factors
            
        Returns:
            Float representing risk level (0.0 to 1.0)
        """
        # Weighted combination of risk factors
        weighted_risk = (
            risk_factors['volatility_risk'] * 0.3 +
            risk_factors['liquidity_risk'] * 0.2 +
            risk_factors['correlation_risk'] * 0.15 +
            risk_factors['tail_risk'] * 0.2 +
            risk_factors['regime_risk'] * 0.15
        )
        
        # Adjust based on posterior beliefs
        vol_component = min(1.0, posterior['volatility_expectation'] / 0.05)
        weighted_risk = min(1.0, weighted_risk * (1 + vol_component * 0.2))
        
        return min(1.0, weighted_risk)
    
    def _calculate_assessment_confidence(
            self, prior: Dict, posterior: Dict, market_data: Dict
    ) -> float:
        """
        Calculate confidence in the risk assessment.
        
        Args:
            prior: Prior beliefs
            posterior: Posterior beliefs
            market_data: Current market data
            
        Returns:
            Float representing confidence (0.0 to 1.0)
        """
        # Confidence increases with more observations
        obs_count = posterior.get('observation_count', 0)
        observation_confidence = min(1.0, obs_count / 100.0)
        
        # Confidence increases with data quality
        data_quality = 1.0  # Simplified - would check data completeness
        if 'indicators' in market_data:
            indicator_count = len(market_data['indicators'])
            data_quality = min(1.0, indicator_count / 10.0)
        
        # Combine factors
        confidence = (
            observation_confidence * 0.6 +
            data_quality * 0.4
        )
        
        return min(1.0, max(0.1, confidence))
    
    async def _store_risk_assessment(self, assessment: RiskAssessment) -> None:
        """
        Store a risk assessment in the database.
        
        Args:
            assessment: RiskAssessment to store
        """
        await self.d1.execute(
            """
            INSERT INTO risk_assessments 
            (assessment_id, symbol, risk_level, confidence, timestamp,
             market_conditions, risk_factors, bayesian_updates)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            assessment.assessment_id, assessment.symbol, assessment.risk_level,
            assessment.confidence, assessment.timestamp.isoformat(),
            json.dumps(assessment.market_conditions),
            json.dumps(assessment.risk_factors),
            json.dumps(assessment.bayesian_updates)
        )
    
    def _calculate_risk_adjusted_position(
            self, proposed_trade: Dict, risk_assessment: RiskAssessment
    ) -> float:
        """
        Calculate risk-adjusted position size.
        
        Args:
            proposed_trade: Proposed trade details
            risk_assessment: Risk assessment for the symbol
            
        Returns:
            Float representing adjusted position size
        """
        # Base position size from proposed trade
        base_size = proposed_trade.get('position_size', 1.0)
        
        # Adjust based on risk level
        risk_multiplier = max(0.1, 1.0 - risk_assessment.risk_level)
        
        # Apply risk tolerance
        tolerance_multiplier = max(0.1, 1.0 - (risk_assessment.risk_level / 
                                              self.risk_params['risk_tolerance']))
        
        # Final adjustment
        adjusted_size = base_size * risk_multiplier * tolerance_multiplier
        
        return max(0.0, adjusted_size)
    
    def _determine_risk_action(
            self, proposed_trade: Dict, risk_assessment: RiskAssessment,
            position_size: float
    ) -> str:
        """
        Determine the risk-based action for a proposed trade.
        
        Args:
            proposed_trade: Proposed trade details
            risk_assessment: Risk assessment
            position_size: Calculated position size
            
        Returns:
            String representing the action ('ACCEPT', 'REJECT', 'MODIFY', 'DEFER')
        """
        # Reject if risk is too high
        if risk_assessment.risk_level > 0.8:
            return 'REJECT'
        
        # Reject if confidence is too low
        if risk_assessment.confidence < 0.3:
            return 'DEFER'
        
        # Modify if position size is significantly reduced
        base_size = proposed_trade.get('position_size', 1.0)
        if position_size < base_size * 0.5:
            return 'MODIFY'
        
        # Accept if within parameters
        if (risk_assessment.risk_level < self.risk_params['confidence_threshold'] and
            risk_assessment.confidence > 0.5):
            return 'ACCEPT'
        
        # Default to defer
        return 'DEFER'
    
    def _generate_risk_reasoning(
            self, proposed_trade: Dict, risk_assessment: RiskAssessment,
            action: str, position_size: float
    ) -> str:
        """
        Generate reasoning for the risk-based decision.
        
        Args:
            proposed_trade: Proposed trade details
            risk_assessment: Risk assessment
            action: Determined action
            position_size: Calculated position size
            
        Returns:
            String with reasoning
        """
        symbol = proposed_trade.get('symbol', 'Unknown')
        base_size = proposed_trade.get('position_size', 1.0)
        
        reasoning_parts = [f"Risk assessment for {symbol}:"]
        
        # Risk level
        if risk_assessment.risk_level > 0.7:
            reasoning_parts.append(f"High risk level ({risk_assessment.risk_level:.2f}) detected.")
        elif risk_assessment.risk_level > 0.4:
            reasoning_parts.append(f"Moderate risk level ({risk_assessment.risk_level:.2f}) detected.")
        else:
            reasoning_parts.append(f"Low risk level ({risk_assessment.risk_level:.2f}) detected.")
        
        # Confidence
        if risk_assessment.confidence > 0.8:
            reasoning_parts.append(f"High confidence ({risk_assessment.confidence:.2f}) in assessment.")
        elif risk_assessment.confidence > 0.5:
            reasoning_parts.append(f"Moderate confidence ({risk_assessment.confidence:.2f}) in assessment.")
        else:
            reasoning_parts.append(f"Low confidence ({risk_assessment.confidence:.2f}) in assessment.")
        
        # Position size adjustment
        if position_size != base_size:
            reduction = (1 - position_size / base_size) * 100
            reasoning_parts.append(f"Position size reduced by {reduction:.1f}% due to risk factors.")
        
        # Action justification
        reasoning_parts.append(f"Action determined as {action} based on risk parameters.")
        
        return " ".join(reasoning_parts)
    
    def _estimate_volatility(self, risk_assessment: RiskAssessment) -> float:
        """
        Estimate expected volatility based on risk assessment.
        
        Args:
            risk_assessment: Risk assessment
            
        Returns:
            Float representing expected volatility
        """
        # Simplified estimation - would use more sophisticated models in practice
        base_vol = risk_assessment.bayesian_updates.get('volatility_expectation', 0.02)
        risk_multiplier = 1.0 + (risk_assessment.risk_level * 0.5)
        return base_vol * risk_multiplier
    
    async def _store_risk_decision(self, decision: RiskDecision) -> None:
        """
        Store a risk decision in the database.
        
        Args:
            decision: RiskDecision to store
        """
        await self.d1.execute(
            """
            INSERT INTO risk_decisions 
            (decision_id, symbol, action, risk_adjusted_position, confidence,
             reasoning, timestamp, expected_volatility)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
            decision.decision_id, decision.symbol, decision.action,
            decision.risk_adjusted_position, decision.confidence,
            decision.reasoning, decision.timestamp.isoformat(),
            decision.expected_volatility
        )
    
    async def _update_risk_models(
            self, symbol: str, risk_assessment: RiskAssessment,
            decision: RiskDecision
    ) -> None:
        """
        Update risk models based on assessment and decision.
        
        Args:
            symbol: Trading symbol
            risk_assessment: Risk assessment
            decision: Risk decision
        """
        # Update in-memory models
        model_key = f"model_{symbol}"
        if model_key not in self.risk_models:
            self.risk_models[model_key] = {
                'assessments': [],
                'decisions': [],
                'performance': []
            }
        
        self.risk_models[model_key]['assessments'].append(asdict(risk_assessment))
        self.risk_models[model_key]['decisions'].append(asdict(decision))
        
        # Store updated priors
        await self.kv.put(
            f"risk_prior_{symbol}", 
            json.dumps(risk_assessment.bayesian_updates)
        )
        
        # Update database with new prior
        await self.d1.execute(
            """
            INSERT OR REPLACE INTO risk_priors 
            (symbol, volatility_expectation, correlation_risk, liquidity_risk,
             tail_risk, observation_count, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?)
            """,
            symbol,
            risk_assessment.bayesian_updates.get('volatility_expectation', 0.02),
            risk_assessment.bayesian_updates.get('correlation_risk', 0.1),
            risk_assessment.bayesian_updates.get('liquidity_risk', 0.05),
            risk_assessment.bayesian_updates.get('tail_risk', 0.01),
            risk_assessment.bayesian_updates.get('observation_count', 0),
            datetime.now().isoformat()
        )