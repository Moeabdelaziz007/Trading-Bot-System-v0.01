#!/usr/bin/env python3
"""
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”„ DATA FLOW PIPELINE | Ø®Ø· Ø£Ù†Ø§Ø¨ÙŠØ¨ ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Purpose: Connect Mini-Agent Swarm outputs to Learning Loop v2.0
Flow: Agents â†’ DataFlowPipeline â†’ LearningLoopBridge â†’ D1/KV Storage

Components:
    - SignalCollector: Aggregates signals from all agents
    - OutcomeTracker: Tracks trade outcomes and labels them
    - PerformanceFeed: Feeds metrics to Learning Loop
    - WeightUpdater: Applies updated weights from consensus

Author: Axiom AI Partner | Mohamed Hossameldin Abdelaziz
Date: December 9, 2025
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""

from dataclasses import dataclass, field, asdict
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from enum import Enum
import json


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“Š DATA MODELS | Ù†Ù…Ø§Ø°Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class SignalDirection(Enum):
    """Signal direction from agents."""
    LONG = "LONG"
    SHORT = "SHORT"
    NEUTRAL = "NEUTRAL"


class TradeOutcome(Enum):
    """Trade outcome classification (Triple Barrier)."""
    UPPER = "UPPER"   # Hit profit target
    LOWER = "LOWER"   # Hit stop loss
    VERTICAL = "VERTICAL"  # Time expired
    PENDING = "PENDING"  # Still open


@dataclass
class AgentSignal:
    """Signal generated by a mini-agent."""
    agent_id: str
    symbol: str
    direction: SignalDirection
    confidence: float  # 0.0 to 1.0
    entry_price: float
    stop_loss: float
    take_profit: float
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            "direction": self.direction.value,
            "timestamp": self.timestamp.isoformat()
        }


@dataclass
class TradeResult:
    """Result of a trade execution."""
    signal_id: str
    agent_id: str
    symbol: str
    entry_price: float
    exit_price: float
    entry_time: datetime
    exit_time: datetime
    outcome: TradeOutcome
    pnl_usd: float
    pnl_pct: float
    
    def to_dict(self) -> Dict:
        return {
            **asdict(self),
            "outcome": self.outcome.value,
            "entry_time": self.entry_time.isoformat(),
            "exit_time": self.exit_time.isoformat()
        }


@dataclass
class AgentMetrics:
    """Performance metrics for an agent."""
    agent_id: str
    total_signals: int = 0
    executed_trades: int = 0
    wins: int = 0
    losses: int = 0
    total_pnl: float = 0.0
    avg_confidence: float = 0.0
    current_weight: float = 0.25
    last_updated: datetime = field(default_factory=datetime.now)
    
    @property
    def win_rate(self) -> float:
        if self.executed_trades == 0:
            return 0.0
        return self.wins / self.executed_trades
    
    @property
    def avg_pnl(self) -> float:
        if self.executed_trades == 0:
            return 0.0
        return self.total_pnl / self.executed_trades


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“¥ SIGNAL COLLECTOR | Ø¬Ø§Ù…Ø¹ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class SignalCollector:
    """
    Collects and buffers signals from all mini-agents.
    Provides aggregation and filtering before sending to Learning Loop.
    """
    
    def __init__(self, buffer_size: int = 100):
        self.buffer_size = buffer_size
        self.signal_buffer: List[AgentSignal] = []
        self.signal_count = 0
    
    def add_signal(self, signal: AgentSignal) -> None:
        """Add a new signal to the buffer."""
        self.signal_buffer.append(signal)
        self.signal_count += 1
        
        # Maintain buffer size
        if len(self.signal_buffer) > self.buffer_size:
            self.signal_buffer.pop(0)
    
    def get_signals_by_agent(self, agent_id: str) -> List[AgentSignal]:
        """Get all buffered signals from a specific agent."""
        return [s for s in self.signal_buffer if s.agent_id == agent_id]
    
    def get_signals_by_symbol(self, symbol: str) -> List[AgentSignal]:
        """Get all buffered signals for a specific symbol."""
        return [s for s in self.signal_buffer if s.symbol == symbol]
    
    def get_high_confidence_signals(
        self, 
        min_confidence: float = 0.7
    ) -> List[AgentSignal]:
        """Get signals with confidence above threshold."""
        return [
            s for s in self.signal_buffer 
            if s.confidence >= min_confidence
        ]
    
    def get_consensus_signals(self) -> Dict[str, Dict]:
        """
        Aggregate signals by symbol to find consensus.
        Returns symbols where multiple agents agree.
        """
        symbol_signals: Dict[str, List[AgentSignal]] = {}
        
        for signal in self.signal_buffer:
            if signal.symbol not in symbol_signals:
                symbol_signals[signal.symbol] = []
            symbol_signals[signal.symbol].append(signal)
        
        consensus = {}
        for symbol, signals in symbol_signals.items():
            if len(signals) < 2:
                continue
            
            # Count directions
            long_count = sum(
                1 for s in signals 
                if s.direction == SignalDirection.LONG
            )
            short_count = sum(
                1 for s in signals 
                if s.direction == SignalDirection.SHORT
            )
            
            # Check for consensus (>= 2 agents agree)
            if long_count >= 2:
                consensus[symbol] = {
                    "direction": "LONG",
                    "agreement": long_count,
                    "total_signals": len(signals),
                    "avg_confidence": sum(
                        s.confidence for s in signals 
                        if s.direction == SignalDirection.LONG
                    ) / long_count
                }
            elif short_count >= 2:
                consensus[symbol] = {
                    "direction": "SHORT",
                    "agreement": short_count,
                    "total_signals": len(signals),
                    "avg_confidence": sum(
                        s.confidence for s in signals 
                        if s.direction == SignalDirection.SHORT
                    ) / short_count
                }
        
        return consensus
    
    def clear_buffer(self) -> None:
        """Clear all buffered signals."""
        self.signal_buffer = []


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“ˆ OUTCOME TRACKER | Ù…ØªØªØ¨Ø¹ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class OutcomeTracker:
    """
    Tracks trade outcomes using Triple Barrier method.
    Labels trades as UPPER (win), LOWER (loss), or VERTICAL (time expired).
    """
    
    def __init__(self, default_timeout_hours: int = 4):
        self.default_timeout = timedelta(hours=default_timeout_hours)
        self.pending_trades: Dict[str, Dict] = {}
        self.completed_trades: List[TradeResult] = []
    
    def open_trade(
        self, 
        signal_id: str, 
        signal: AgentSignal, 
        timeout: Optional[timedelta] = None
    ) -> None:
        """Register a new trade from a signal."""
        self.pending_trades[signal_id] = {
            "signal": signal,
            "entry_time": datetime.now(),
            "timeout": timeout or self.default_timeout
        }
    
    def check_barriers(
        self, 
        signal_id: str, 
        current_price: float
    ) -> Optional[TradeResult]:
        """
        Check if trade hit any barrier.
        Returns TradeResult if barrier hit, None otherwise.
        """
        if signal_id not in self.pending_trades:
            return None
        
        trade = self.pending_trades[signal_id]
        signal: AgentSignal = trade["signal"]
        entry_time: datetime = trade["entry_time"]
        timeout: timedelta = trade["timeout"]
        
        outcome = None
        
        # Check upper barrier (take profit)
        if signal.direction == SignalDirection.LONG:
            if current_price >= signal.take_profit:
                outcome = TradeOutcome.UPPER
            elif current_price <= signal.stop_loss:
                outcome = TradeOutcome.LOWER
        else:  # SHORT
            if current_price <= signal.take_profit:
                outcome = TradeOutcome.UPPER
            elif current_price >= signal.stop_loss:
                outcome = TradeOutcome.LOWER
        
        # Check vertical barrier (time)
        if outcome is None and datetime.now() - entry_time > timeout:
            outcome = TradeOutcome.VERTICAL
        
        if outcome is not None:
            # Calculate PnL
            if signal.direction == SignalDirection.LONG:
                pnl_pct = (
                    (current_price - signal.entry_price) / 
                    signal.entry_price
                ) * 100
            else:
                pnl_pct = (
                    (signal.entry_price - current_price) / 
                    signal.entry_price
                ) * 100
            
            result = TradeResult(
                signal_id=signal_id,
                agent_id=signal.agent_id,
                symbol=signal.symbol,
                entry_price=signal.entry_price,
                exit_price=current_price,
                entry_time=entry_time,
                exit_time=datetime.now(),
                outcome=outcome,
                pnl_usd=0.0,  # Would need position size
                pnl_pct=pnl_pct
            )
            
            # Move to completed
            del self.pending_trades[signal_id]
            self.completed_trades.append(result)
            
            return result
        
        return None
    
    def get_agent_outcomes(
        self, 
        agent_id: str
    ) -> List[TradeResult]:
        """Get all completed trades for an agent."""
        return [
            t for t in self.completed_trades 
            if t.agent_id == agent_id
        ]


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ“Š PERFORMANCE FEED | ØªØºØ°ÙŠØ© Ø§Ù„Ø£Ø¯Ø§Ø¡
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class PerformanceFeed:
    """
    Feeds agent performance data to Learning Loop v2.0.
    Maintains rolling metrics and prepares data for weight updates.
    """
    
    AGENT_IDS = [
        "momentum_scout",
        "reversion_hunter", 
        "liquidity_watcher",
        "volatility_spiker"
    ]
    
    def __init__(self):
        self.agent_metrics: Dict[str, AgentMetrics] = {
            agent_id: AgentMetrics(agent_id=agent_id)
            for agent_id in self.AGENT_IDS
        }
    
    def record_signal(
        self, 
        agent_id: str, 
        confidence: float
    ) -> None:
        """Record a new signal from an agent."""
        if agent_id in self.agent_metrics:
            metrics = self.agent_metrics[agent_id]
            metrics.total_signals += 1
            # Update rolling average confidence
            n = metrics.total_signals
            metrics.avg_confidence = (
                metrics.avg_confidence * (n - 1) + confidence
            ) / n
    
    def record_outcome(self, result: TradeResult) -> None:
        """Record a trade outcome for an agent."""
        if result.agent_id in self.agent_metrics:
            metrics = self.agent_metrics[result.agent_id]
            metrics.executed_trades += 1
            metrics.total_pnl += result.pnl_pct
            
            if result.outcome == TradeOutcome.UPPER:
                metrics.wins += 1
            elif result.outcome == TradeOutcome.LOWER:
                metrics.losses += 1
            # VERTICAL counts as neither win nor loss
            
            metrics.last_updated = datetime.now()
    
    def get_performance_summary(self) -> Dict[str, Dict]:
        """Get performance summary for all agents."""
        return {
            agent_id: {
                "total_signals": m.total_signals,
                "executed_trades": m.executed_trades,
                "win_rate": round(m.win_rate, 4),
                "avg_pnl": round(m.avg_pnl, 4),
                "avg_confidence": round(m.avg_confidence, 4),
                "current_weight": round(m.current_weight, 4)
            }
            for agent_id, m in self.agent_metrics.items()
        }
    
    def prepare_learning_loop_payload(self) -> Dict:
        """
        Prepare data payload for Learning Loop v2.0.
        Format compatible with WeightedConsensusEngine.
        """
        return {
            "timestamp": datetime.now().isoformat(),
            "agent_count": len(self.AGENT_IDS),
            "agents": self.get_performance_summary(),
            "total_signals": sum(
                m.total_signals for m in self.agent_metrics.values()
            ),
            "total_trades": sum(
                m.executed_trades for m in self.agent_metrics.values()
            ),
            "avg_win_rate": sum(
                m.win_rate for m in self.agent_metrics.values()
            ) / len(self.AGENT_IDS) if self.AGENT_IDS else 0
        }


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# âš–ï¸ WEIGHT UPDATER | Ù…Ø­Ø¯Ø« Ø§Ù„Ø£ÙˆØ²Ø§Ù†
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class WeightUpdater:
    """
    Receives updated weights from Learning Loop v2.0.
    Applies Softmax ensemble weighting to agents.
    """
    
    def __init__(self, beta: float = 2.0):
        self.beta = beta  # Softmax temperature
        self.weight_history: List[Dict] = []
    
    def calculate_softmax_weights(
        self, 
        performance_feed: PerformanceFeed
    ) -> Dict[str, float]:
        """
        Calculate Softmax weights based on agent performance.
        W_i = exp(Î² Ã— P_i) / Î£ exp(Î² Ã— P_j)
        """
        import math
        
        scores = {}
        for agent_id, metrics in performance_feed.agent_metrics.items():
            # Performance score = win_rate Ã— (1 + normalized_pnl)
            pnl_factor = 1 + (metrics.avg_pnl / 100)
            scores[agent_id] = metrics.win_rate * pnl_factor
        
        # Softmax calculation
        exp_scores = {
            k: math.exp(self.beta * v) 
            for k, v in scores.items()
        }
        total = sum(exp_scores.values())
        
        if total == 0:
            # Equal weights if no data
            return {k: 0.25 for k in scores}
        
        weights = {k: v / total for k, v in exp_scores.items()}
        
        # Record history
        self.weight_history.append({
            "timestamp": datetime.now().isoformat(),
            "weights": weights
        })
        
        return weights
    
    def apply_weights(
        self, 
        weights: Dict[str, float],
        performance_feed: PerformanceFeed
    ) -> None:
        """Apply new weights to agent metrics."""
        for agent_id, weight in weights.items():
            if agent_id in performance_feed.agent_metrics:
                performance_feed.agent_metrics[agent_id].current_weight = weight


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ”„ DATA FLOW PIPELINE | Ø®Ø· Ø£Ù†Ø§Ø¨ÙŠØ¨ ØªØ¯ÙÙ‚ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class DataFlowPipeline:
    """
    Main orchestrator for data flow from agents to Learning Loop.
    Coordinates all components and manages the data lifecycle.
    """
    
    def __init__(self):
        self.signal_collector = SignalCollector()
        self.outcome_tracker = OutcomeTracker()
        self.performance_feed = PerformanceFeed()
        self.weight_updater = WeightUpdater()
    
    async def process_agent_signal(self, signal: AgentSignal) -> Dict:
        """
        Process a new signal from an agent.
        Returns processing result with consensus info.
        """
        # Collect signal
        self.signal_collector.add_signal(signal)
        
        # Record in performance feed
        self.performance_feed.record_signal(
            signal.agent_id, 
            signal.confidence
        )
        
        # Check for consensus
        consensus = self.signal_collector.get_consensus_signals()
        
        return {
            "signal_received": True,
            "agent_id": signal.agent_id,
            "symbol": signal.symbol,
            "consensus": consensus.get(signal.symbol)
        }
    
    async def process_price_update(
        self, 
        symbol: str, 
        current_price: float
    ) -> List[TradeResult]:
        """
        Process a price update and check for barrier hits.
        Returns list of completed trades.
        """
        completed = []
        
        for signal_id in list(self.outcome_tracker.pending_trades.keys()):
            trade = self.outcome_tracker.pending_trades[signal_id]
            if trade["signal"].symbol == symbol:
                result = self.outcome_tracker.check_barriers(
                    signal_id, 
                    current_price
                )
                if result:
                    # Record outcome in performance feed
                    self.performance_feed.record_outcome(result)
                    completed.append(result)
        
        return completed
    
    async def update_weights(self) -> Dict[str, float]:
        """
        Trigger weight recalculation based on current performance.
        Returns new weights.
        """
        weights = self.weight_updater.calculate_softmax_weights(
            self.performance_feed
        )
        self.weight_updater.apply_weights(weights, self.performance_feed)
        return weights
    
    async def get_learning_loop_payload(self) -> Dict:
        """Get data payload for Learning Loop v2.0."""
        return self.performance_feed.prepare_learning_loop_payload()
    
    async def get_status(self) -> Dict:
        """Get current pipeline status."""
        return {
            "buffered_signals": len(self.signal_collector.signal_buffer),
            "pending_trades": len(self.outcome_tracker.pending_trades),
            "completed_trades": len(self.outcome_tracker.completed_trades),
            "agents": self.performance_feed.get_performance_summary(),
            "timestamp": datetime.now().isoformat()
        }


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ­ FACTORY | Ø§Ù„Ù…ØµÙ†Ø¹
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

# Global pipeline instance
_pipeline_instance: Optional[DataFlowPipeline] = None


def get_pipeline() -> DataFlowPipeline:
    """Get or create the global pipeline instance."""
    global _pipeline_instance
    if _pipeline_instance is None:
        _pipeline_instance = DataFlowPipeline()
    return _pipeline_instance


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ğŸ§ª TEST | Ø§Ø®ØªØ¨Ø§Ø±
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

if __name__ == "__main__":
    import asyncio
    
    async def test_pipeline():
        print("â”" * 60)
        print("ğŸ”„ DATA FLOW PIPELINE TEST")
        print("â”" * 60)
        
        pipeline = get_pipeline()
        
        # Create test signals
        signals = [
            AgentSignal(
                agent_id="momentum_scout",
                symbol="BTCUSDT",
                direction=SignalDirection.LONG,
                confidence=0.85,
                entry_price=96000.0,
                stop_loss=95000.0,
                take_profit=98000.0
            ),
            AgentSignal(
                agent_id="volatility_spiker",
                symbol="BTCUSDT",
                direction=SignalDirection.LONG,
                confidence=0.78,
                entry_price=96000.0,
                stop_loss=95000.0,
                take_profit=98000.0
            ),
        ]
        
        # Process signals
        for signal in signals:
            result = await pipeline.process_agent_signal(signal)
            print(f"âœ… Processed signal from {signal.agent_id}")
            if result.get("consensus"):
                print(f"   ğŸ¯ Consensus found: {result['consensus']}")
        
        # Update weights
        weights = await pipeline.update_weights()
        print(f"\nâš–ï¸ Updated weights: {weights}")
        
        # Get status
        status = await pipeline.get_status()
        print(f"\nğŸ“Š Pipeline status:")
        print(f"   Buffered signals: {status['buffered_signals']}")
        print(f"   Pending trades: {status['pending_trades']}")
        
        # Get Learning Loop payload
        payload = await pipeline.get_learning_loop_payload()
        print(f"\nğŸ“¤ Learning Loop payload:")
        print(f"   Total signals: {payload['total_signals']}")
        print(f"   Agent count: {payload['agent_count']}")
        
        print("\n" + "â”" * 60)
        print("âœ… Pipeline test complete!")
        print("â”" * 60)
    
    asyncio.run(test_pipeline())
