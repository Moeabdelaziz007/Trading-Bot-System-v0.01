"""
ðŸ Base Mini-Agent - Abstract Base Class for All Swarm Agents
Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ø¬Ù…ÙŠØ¹ ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ø³Ø±Ø¨ Ø§Ù„Ù…ØµØºØ±ÙŠÙ†

AlphaAxiom Learning Loop v2.0
Author: Axiom AI Partner
Status: ACTIVE as of December 9, 2025

This base class provides:
- Common signal generation interface
- TRADING_MODE compliance
- DriftGuard integration
- D1 database logging
- Error handling pipeline
- Alpaca Paper Trading integration
"""

import json
import os
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any, List
import uuid


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ðŸ“Š SIGNAL TYPES | Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ø¥Ø´Ø§Ø±Ø§Øª
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class SignalType(Enum):
    """Trading signal types | Ø£Ù†ÙˆØ§Ø¹ Ø¥Ø´Ø§Ø±Ø§Øª Ø§Ù„ØªØ¯Ø§ÙˆÙ„"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class TradingMode(Enum):
    """Execution modes | Ø£ÙˆØ¶Ø§Ø¹ Ø§Ù„ØªÙ†ÙÙŠØ°"""
    SIMULATION = "SIMULATION"  # Logs only, no API calls
    PAPER = "PAPER"            # Alpaca Paper Trading API
    LIVE = "LIVE"              # BLOCKED for mini-agents


class MarketRegime(Enum):
    """Market regime based on Hurst Exponent | Ù†Ø¸Ø§Ù… Ø§Ù„Ø³ÙˆÙ‚"""
    TRENDING = "TRENDING"       # H > 0.55
    MEAN_REVERTING = "MEAN_REVERTING"  # H < 0.45
    RANDOM_WALK = "RANDOM_WALK"  # 0.45 <= H <= 0.55


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ðŸ“¦ DATA CLASSES | ÙØ¦Ø§Øª Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

@dataclass
class AgentSignal:
    """
    Trading signal generated by a mini-agent
    Ø¥Ø´Ø§Ø±Ø© ØªØ¯Ø§ÙˆÙ„ Ù…ÙˆÙ„Ø¯Ø© Ù…Ù† ÙˆÙƒÙŠÙ„ Ù…ØµØºØ±
    """
    signal_id: str
    agent_name: str
    timestamp: int
    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 - 1.0
    entry_price: float
    hypothesis: str
    market_regime: Optional[str] = None
    
    # Optional targets
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    
    # Metadata
    indicators: Dict[str, Any] = field(default_factory=dict)
    reasoning: str = ""
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "signal_id": self.signal_id,
            "agent_name": self.agent_name,
            "timestamp": self.timestamp,
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "confidence": self.confidence,
            "entry_price": self.entry_price,
            "hypothesis": self.hypothesis,
            "market_regime": self.market_regime,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "indicators": self.indicators,
            "reasoning": self.reasoning,
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AgentSignal":
        """Create from dictionary"""
        data["signal_type"] = SignalType(data["signal_type"])
        return cls(**data)


@dataclass
class TradeOutcome:
    """
    Result of a paper trade execution
    Ù†ØªÙŠØ¬Ø© ØªÙ†ÙÙŠØ° ØµÙÙ‚Ø© ÙˆØ±Ù‚ÙŠØ©
    """
    outcome_id: str
    signal_id: str
    exit_timestamp: int
    exit_price: float
    pnl: float  # Profit/Loss in percentage
    duration_minutes: int
    prediction_correct: bool  # Did price move as predicted?
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        return {
            "outcome_id": self.outcome_id,
            "signal_id": self.signal_id,
            "exit_timestamp": self.exit_timestamp,
            "exit_price": self.exit_price,
            "pnl": self.pnl,
            "duration_minutes": self.duration_minutes,
            "prediction_correct": 1 if self.prediction_correct else 0,
        }


@dataclass
class AgentPerformance:
    """
    Performance metrics for an agent
    Ù…Ù‚Ø§ÙŠÙŠØ³ Ø£Ø¯Ø§Ø¡ Ø§Ù„ÙˆÙƒÙŠÙ„
    """
    agent_name: str
    window_end: int  # Timestamp
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    sharpe_ratio: float
    max_drawdown: float
    profit_factor: float
    current_score: float
    current_weight: float
    current_rank: int
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "agent_name": self.agent_name,
            "window_end": self.window_end,
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": self.win_rate,
            "sharpe_ratio": self.sharpe_ratio,
            "max_drawdown": self.max_drawdown,
            "profit_factor": self.profit_factor,
            "current_score": self.current_score,
            "current_weight": self.current_weight,
            "current_rank": self.current_rank,
        }


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ðŸ BASE MINI-AGENT CLASS | Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„ÙˆÙƒÙŠÙ„ Ø§Ù„Ù…ØµØºØ±
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

class BaseMiniAgent(ABC):
    """
    Abstract base class for all mini-agents in the swarm.
    Ø§Ù„ÙØ¦Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø¬Ø±Ø¯Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„ÙˆÙƒÙ„Ø§Ø¡ Ø§Ù„Ù…ØµØºØ±ÙŠÙ† ÙÙŠ Ø§Ù„Ø³Ø±Ø¨
    
    Each mini-agent:
    - Tests a specific market hypothesis
    - Generates signals for paper trading
    - Logs all actions to D1 database
    - Respects TRADING_MODE and DriftGuard
    """
    
    # Class constants
    VERSION = "1.0.0"
    
    # Default trading parameters
    DEFAULT_STOP_LOSS_PERCENT = 2.0  # 2% stop loss
    DEFAULT_TAKE_PROFIT_PERCENT = 4.0  # 4% take profit (2:1 R:R)
    DEFAULT_CONFIDENCE_THRESHOLD = 0.6  # Min confidence to signal
    
    def __init__(self, env=None):
        """
        Initialize the mini-agent
        
        Args:
            env: Cloudflare Workers environment object
        """
        self.env = env
        
        # Get trading mode from environment
        self._trading_mode = self._get_trading_mode()
        
        # Agent identification
        self._agent_name = self.__class__.__name__
        
        # Default watchlist (can be overridden)
        self.watchlist = ["BTCUSD", "ETHUSD", "SPY", "EURUSD"]
        
        # Current weight (updated by PerformanceMonitor)
        self.current_weight = 1.0
        
        # Is agent paused by contest manager?
        self.is_paused = False
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸŽ¯ ABSTRACT METHODS (Must be implemented)
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    @property
    @abstractmethod
    def hypothesis(self) -> str:
        """
        The market hypothesis this agent is testing.
        Must be implemented by subclasses.
        """
        pass
    
    @property
    @abstractmethod
    def timeframes(self) -> List[str]:
        """
        Timeframes this agent operates on (e.g., ["1M", "5M"])
        """
        pass
    
    @abstractmethod
    async def analyze_market(self, symbol: str, market_data: Dict[str, Any]) -> Optional[AgentSignal]:
        """
        Analyze market data and generate a signal if conditions are met.
        
        Args:
            symbol: Trading symbol (e.g., "BTCUSD")
            market_data: OHLCV and indicator data
            
        Returns:
            AgentSignal if a trade opportunity is found, None otherwise
        """
        pass
    
    @abstractmethod
    def calculate_indicators(self, ohlcv: List[Dict]) -> Dict[str, Any]:
        """
        Calculate technical indicators needed for this agent's hypothesis.
        
        Args:
            ohlcv: List of OHLCV candles
            
        Returns:
            Dictionary of calculated indicators
        """
        pass
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸš€ CORE EXECUTION METHODS
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    async def run(self) -> List[AgentSignal]:
        """
        Main execution method - called by Cron Trigger
        
        Returns:
            List of generated signals
        """
        # Safety checks
        if not self._check_safety():
            return []
        
        # Check if agent is paused
        if self.is_paused:
            self._log(f"â¸ï¸ Agent paused by ContestManager")
            return []
        
        signals = []
        
        for symbol in self.watchlist:
            try:
                # Fetch market data
                market_data = await self._fetch_market_data(symbol)
                
                if not market_data:
                    continue
                
                # Analyze and generate signal
                signal = await self.analyze_market(symbol, market_data)
                
                if signal and signal.confidence >= self.DEFAULT_CONFIDENCE_THRESHOLD:
                    # Execute paper trade if in PAPER mode
                    await self._execute_signal(signal)
                    
                    # Log to D1 database
                    await self._log_signal(signal)
                    
                    signals.append(signal)
                    
            except Exception as e:
                self._log(f"âŒ Error analyzing {symbol}: {e}")
                await self._log_error(symbol, str(e))
        
        return signals
    
    async def _execute_signal(self, signal: AgentSignal) -> bool:
        """
        Execute a paper trade via Alpaca Paper Trading API
        
        Args:
            signal: The signal to execute
            
        Returns:
            True if executed successfully
        """
        if self._trading_mode == TradingMode.SIMULATION:
            self._log(f"ðŸ§ª SIMULATION: Would execute {signal.signal_type.value} on {signal.symbol}")
            return True
        
        if self._trading_mode == TradingMode.LIVE:
            self._log("ðŸš« BLOCKED: Mini-agents cannot execute LIVE trades")
            return False
        
        # PAPER mode - execute via Alpaca Paper API
        try:
            # Here we would call Alpaca Paper Trading API
            # For now, we log the intended trade
            self._log(f"ðŸ“„ PAPER TRADE: {signal.signal_type.value} {signal.symbol} @ {signal.entry_price}")
            
            # In real implementation:
            # from ..brokers.gateway import BrokerGateway
            # gateway = BrokerGateway(self.env)
            # result = await gateway.execute_paper_trade(signal)
            
            return True
            
        except Exception as e:
            self._log(f"âŒ Paper trade failed: {e}")
            return False
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸ›¡ï¸ SAFETY METHODS
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    def _check_safety(self) -> bool:
        """
        Verify all safety conditions before executing
        
        Returns:
            True if safe to proceed
        """
        # Check trading mode
        if self._trading_mode == TradingMode.LIVE:
            self._log("ðŸš« SAFETY: Mini-agents blocked in LIVE mode")
            return False
        
        # Check DriftGuard status (if available)
        drift_healthy = self._check_drift_guard()
        if not drift_healthy:
            self._log("ðŸ›¡ï¸ SAFETY: DriftGuard detected drift, pausing agent")
            return False
        
        return True
    
    def _check_drift_guard(self) -> bool:
        """
        Check DriftGuard health status
        
        Returns:
            True if no drift detected
        """
        # In real implementation, check via KV or DriftGuard instance
        # For now, assume healthy
        return True
    
    def _get_trading_mode(self) -> TradingMode:
        """Get TRADING_MODE from environment"""
        if self.env:
            mode_str = getattr(self.env, 'TRADING_MODE', 'SIMULATION')
        else:
            mode_str = os.environ.get('TRADING_MODE', 'SIMULATION')
        
        try:
            return TradingMode(mode_str.upper())
        except ValueError:
            return TradingMode.SIMULATION
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸ“Š DATA METHODS
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    async def _fetch_market_data(self, symbol: str) -> Optional[Dict[str, Any]]:
        """
        Fetch market data for a symbol
        
        Args:
            symbol: Trading symbol
            
        Returns:
            Market data dictionary with OHLCV and indicators
        """
        try:
            # In real implementation, fetch from Alpaca/broker API
            # For now, return mock data for testing
            
            # Mock OHLCV data
            ohlcv = self._generate_mock_ohlcv()
            
            # Calculate indicators
            indicators = self.calculate_indicators(ohlcv)
            
            return {
                "symbol": symbol,
                "timestamp": int(datetime.now().timestamp()),
                "ohlcv": ohlcv,
                "indicators": indicators,
                "current_price": ohlcv[-1]["close"] if ohlcv else 0,
            }
            
        except Exception as e:
            self._log(f"âŒ Failed to fetch data for {symbol}: {e}")
            return None
    
    def _generate_mock_ohlcv(self, periods: int = 100) -> List[Dict]:
        """Generate mock OHLCV data for testing"""
        import random
        
        base_price = 50000  # BTC-like price
        ohlcv = []
        
        for i in range(periods):
            change = random.uniform(-0.02, 0.02)
            open_price = base_price * (1 + random.uniform(-0.005, 0.005))
            close_price = open_price * (1 + change)
            high = max(open_price, close_price) * (1 + random.uniform(0, 0.01))
            low = min(open_price, close_price) * (1 - random.uniform(0, 0.01))
            volume = random.uniform(100, 1000)
            
            ohlcv.append({
                "open": open_price,
                "high": high,
                "low": low,
                "close": close_price,
                "volume": volume,
            })
            
            base_price = close_price
        
        return ohlcv
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸ“ LOGGING METHODS
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    async def _log_signal(self, signal: AgentSignal) -> bool:
        """
        Log signal to D1 database
        
        Args:
            signal: The signal to log
        """
        try:
            # In real implementation, use D1
            # await self.env.DB.prepare(
            #     "INSERT INTO mini_agent_signals ..."
            # ).bind(...).run()
            
            self._log(f"ðŸ“Š Signal logged: {signal.signal_type.value} {signal.symbol}")
            return True
            
        except Exception as e:
            self._log(f"âŒ Failed to log signal: {e}")
            return False
    
    async def _log_error(self, symbol: str, error: str) -> None:
        """Log an error to D1 database"""
        self._log(f"âŒ Error logged for {symbol}: {error}")
    
    def _log(self, message: str) -> None:
        """Print log message with agent prefix"""
        print(f"[{self._agent_name}] {message}")
    
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    # ðŸ”§ UTILITY METHODS
    # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    
    def generate_signal_id(self) -> str:
        """Generate unique signal ID"""
        return f"{self._agent_name}_{uuid.uuid4().hex[:12]}"
    
    def get_current_timestamp(self) -> int:
        """Get current Unix timestamp"""
        return int(datetime.now().timestamp())
    
    def calculate_targets(
        self, 
        entry_price: float, 
        signal_type: SignalType
    ) -> tuple:
        """
        Calculate stop loss and take profit targets
        
        Returns:
            (stop_loss, take_profit)
        """
        if signal_type == SignalType.BUY:
            stop_loss = entry_price * (1 - self.DEFAULT_STOP_LOSS_PERCENT / 100)
            take_profit = entry_price * (1 + self.DEFAULT_TAKE_PROFIT_PERCENT / 100)
        else:  # SELL
            stop_loss = entry_price * (1 + self.DEFAULT_STOP_LOSS_PERCENT / 100)
            take_profit = entry_price * (1 - self.DEFAULT_TAKE_PROFIT_PERCENT / 100)
        
        return (stop_loss, take_profit)
    
    def get_status(self) -> Dict[str, Any]:
        """Get current agent status"""
        return {
            "agent_name": self._agent_name,
            "version": self.VERSION,
            "hypothesis": self.hypothesis,
            "timeframes": self.timeframes,
            "trading_mode": self._trading_mode.value,
            "current_weight": self.current_weight,
            "is_paused": self.is_paused,
            "watchlist": self.watchlist,
        }


# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
# ðŸ­ FACTORY FUNCTION
# â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

def get_all_agents(env=None) -> List[BaseMiniAgent]:
    """
    Factory function to instantiate all mini-agents
    
    Args:
        env: Cloudflare Workers environment
        
    Returns:
        List of all mini-agent instances
    """
    from .momentum_scout import MomentumScout
    from .reversion_hunter import ReversionHunter
    from .liquidity_watcher import LiquidityWatcher
    from .volatility_spiker import VolatilitySpiker
    
    return [
        MomentumScout(env),
        ReversionHunter(env),
        LiquidityWatcher(env),
        VolatilitySpiker(env),
    ]
